<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
    <title>QTOOLS</title>
    <style type="text/css">
      code a{text-decoration:none;}
      h1{display:inline-block;font-size: 28pt;margin-bottom:0;}
      code{font-family: Consolas, Inconsolata, monospace;}
      h4{display: inline-block;margin:0;padding:0;}
      #symbol-index ul{list-style: none;}
      .package li{margin-bottom: 20px;}
      .package pre{margin: 0 0 0 10px; white-space: pre-wrap;}
      .package .nicknames{font-size: 12pt; font-weight: normal;}
      table{margin: 20px;}
      td{padding-bottom: 10px;}
    </style>
  </head>
  <body>
    <header>
      <h1><img src="qtools-logo.png" alt="qtools"/></h1>
      <span>0.5.1</span>
      <p>A collection of tools to aid in development with CommonQt.</p>
    </header>
    <div id="content">
      <article>
        <c:documentate>
          <span><h2>About Qtools</h2>

<p>Qtools is a collection of utilities to help development with CommonQt. There are a lot of things in there, from name mapping over garbage handling to widget class definition. Some tools are straightforward, others are quite complex. I'll try to explain everything as best I can.</p>

<h2>How To</h2>

<p>For Qtools to work you'll obviously need a working <a href="http://common-lisp.net/project/commonqt/">CommonQt</a>. Knowing a bit about CommonQt and Qt development will also help in understanding these tools.</p>

<h3>Basic Tools</h3>

<h4>Names</h4>

<p>Since Qt is a C++ library we're dealing with different naming conventions and different type designators. Qtools offers some help in dealing with both. Mapping more lisp-y class names to the equivalent Qt class names can be done with <code><a href="#QTOOLS:FIND-QT-CLASS-NAME">find-qt-class-name</a></code>. It translates things like the symbol <code>qwidget</code>, or even <code>q-widget</code> into <code>&quot;QWidget&quot;</code>. In order to guess the correct capitalisation it uses a predefined set of names from <code><a href="#QTOOLS:*QT-CLASS-MAP*">*qt-class-map*</a></code>.</p>

<p>Translating a lispy function name symbol into a C++ method name can be done with <code><a href="#QTOOLS:TO-METHOD-NAME">to-method-name</a></code>. Example, <code><a href="#QTOOLS:TO-METHOD-NAME">to-method-name</a></code> would become <code>&quot;toMethodName&quot;</code>.</p>

<p>C++/Qt also has a different set of types than CL, but we need the type names to define things like signals and slots. The functions <code><a href="#QTOOLS:QT-TYPE-OF">qt-type-of</a></code>, <code><a href="#QTOOLS:QT-TYPE-FOR">qt-type-for</a></code>, <code><a href="#QTOOLS:TO-TYPE-NAME">to-type-name</a></code>, <code><a href="#QTOOLS:CL-TYPE-FOR">cl-type-for</a></code>, <code><a href="#QTOOLS:EQT-TYPE-OF">eqt-type-of</a></code> and <code><a href="#QTOOLS:ECL-TYPE-FOR">ecl-type-for</a></code> can help with that by attempting to translate between the two worlds. Using these may be dangerous, as the type information might be ambiguous or no proper translation exists at all, so the results might not always be exactly what you need.</p>

<p>Also useful for full method name (including argument types) translation are <code><a href="#QTOOLS:DETERMINED-TYPE-METHOD-NAME">determined-type-method-name</a></code> and <code><a href="#QTOOLS:SPECIFIED-TYPE-METHOD-NAME">specified-type-method-name</a></code>.</p>

<h4>Other Stuff</h4>

<p>Aside from name handling, Qtools also offers some convenience functions like <code>copy-qobject</code>, <code><a href="#QTOOLS:MAYBE-DELETE-QOBJECT">maybe-delete-qobject</a></code> and <code><a href="#QTOOLS:QTENUMCASE">qtenumcase</a></code> to ease handling of Qt objects.</p>

<h3>Working Without GC</h3>

<p>One major headache when working with CommonQt is the lack of garbage collection for Qt objects. This is something that is unavoidable, short of adding a garbage collector C++-side, and even then synchronising the two worlds would be a big undertaking. Qtools attempts to ease the pain by providing functions to at least have some form of GC, or in the very least minimise the need to keep track of instances.</p>

<p>Central to this effort is the <code><a href="#QTOOLS:FINALIZE">finalize</a></code> generic function. This function should be called on any object that you want to discard. By default, objects of type <code>abstract-qobject</code> and <code><a href="#QTOOLS:FINALIZABLE">finalizable</a></code> are specially handled. Qobjects are automatically deleted so they won't linger on the C++ side and <code><a href="#QTOOLS:FINALIZABLE">finalizable</a></code>s are taken care of by calling <code><a href="#QTOOLS:FINALIZE">finalize</a></code> on all their <code><a href="#QTOOLS:FINALIZED">finalized</a></code> slots.</p>

<p>The <code><a href="#QTOOLS:FINALIZABLE">finalizable</a></code> class (which you can subclass with <code><a href="#QTOOLS:DEFINE-FINALIZABLE">define-finalizable</a></code>) offers a different slot type with the extra argument <code>:finalizable</code>. If that argument is non-NIL, the slot's value is <code><a href="#QTOOLS:FINALIZE">finalize</a></code>d when the object is <code><a href="#QTOOLS:FINALIZE">finalize</a></code>d. Of course you don't need to use the <code><a href="#QTOOLS:FINALIZED">finalized</a></code> class and can instead define methods for your own classes to handle cleanup explicitly.</p>

<p>If you only need to have certain objects around for the duration of a let body or something similar, you may find the <code><a href="#QTOOLS:WITH-FINALIZING">with-finalizing</a></code> and <code><a href="#QTOOLS:WITH-FINALIZING*">with-finalizing*</a></code> functions of use.</p>

<p>As an attempt to automate garbage collection, you can also take advantage of the <code><a href="#QTOOLS:GC-FINALIZED">gc-finalized</a></code> object. This object is a container for another object. Once the gc-finalized object loses all its references and is then at some point hit by the GC, <code><a href="#QTOOLS:FINALIZE">finalize</a></code> is automatically invoked on the contained object. For this to work properly, the container needs to have references for as long as you need the inner object. This might be dangerous if, for example, your contained object is referenced on the C++ side, but the container loses all its references on the CL side. That would result in the C++ object being finalized (and thus deleted), which might cause instability. Always be sure to keep the references in sync if you use the <code><a href="#QTOOLS:GC-FINALIZED">gc-finalized</a></code> object.</p>

<p>However, the <code><a href="#QTOOLS:GC-FINALIZED">gc-finalized</a></code> object can be useful when used with <code><a href="#QTOOLS:WITH-GC-FINALIZED">with-gc-finalized</a></code>, as an alternative to the <code><a href="#QTOOLS:WITH-FINALIZING">with-finalizing</a></code> macro. With this macro, the values are automatically wrapped in a gc-finalized object, but also made convenient by providing a symbol-macro to automatically unwrap the contained object so it feels like a standard let. Once the block exits the objects are then not immediately finalized, but instead the containers lose their references and are thus garbage collected whenever the gc next hits.</p>

<p>Even with these tools, keeping track of objects is a pain and something you'll have to be careful about. I wish there was a way to have full garbage collection, but alas, life is difficult.</p>

<h3>Signals</h3>

<p>Qtools offers some small macros to wrap around CommonQt's direct exposing of C++ names and types. This is especially noticeable with signals (the <code>connect</code> and <code>emit-signal</code> functions). To make these more lispy, you may use <code><a href="#QTOOLS:CONNECT!">connect!</a></code> and <code><a href="#QTOOLS:SIGNAL!">signal!</a></code>:</p>

<pre><code>(<a href="#QTOOLS:CONNECT!">connect!</a> origin (signal-name int double) target (slot-name int double))
(<a href="#QTOOLS:SIGNAL!">signal!</a> target slot-name (0 int) (1.0 double))
</code></pre>

<p>These still require explicit type declaration though. Unfortunately, this is often necessary due to ambiguity or type mismatch. If you're feeling lucky, you may use <code><a href="#QTOOLS:GENERIC-SIGNAL">generic-signal</a></code>, which attempts to statically and dynamically determine the proper types for its arguments:</p>

<pre><code>(<a href="#QTOOLS:GENERIC-SIGNAL">generic-signal</a> target 'slot-name 0 1.0)
</code></pre>

<p>If you want to use <code><a href="#QTOOLS:GENERIC-SIGNAL">generic-signal</a></code> to dynamically determine only some arguments, you can wrap the ones you want to declare explicitly in a list:</p>

<pre><code>(<a href="#QTOOLS:GENERIC-SIGNAL">generic-signal</a> target 'slot-name dynamic `(,fixed double))
</code></pre>

<h3>The Widget Class</h3>

<p>CommonQt's default class adds options that are necessary for proper Qt integration, such as overrides, slots and signals. However, the usage thereof is a big annoying. Qtools offers a separate metaclass/class pair that should handle this much more elegantly. In order to define widgets, you should use <code><a href="#QTOOLS:DEFINE-WIDGET">define-widget</a></code>. This will automatically set the proper metaclass and superclasses:</p>

<pre><code>(<a href="#QTOOLS:DEFINE-WIDGET">define-widget</a> my-widget (QWidget)
  ())
</code></pre>

<p>As you can see, it doesn't require string-escaping the Qt class name, as it can leverage <code><a href="#QTOOLS:FIND-QT-CLASS-NAME">find-qt-class-name</a></code>. Aside form this minor convenience in definition shortage, a widget class keeps track of a few more things for you, which allow changing of class options outside of the definition form itself. This is useful precisely because it allows us to use a much more lispy approach to widget definition that would ordinarily be possible. With widgets you have access to <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code>, <code><a href="#QTOOLS:DEFINE-SLOT">define-slot</a></code>, <code><a href="#QTOOLS:DEFINE-OVERRIDE">define-override</a></code>, <code><a href="#QTOOLS:DEFINE-INITIALIZER">define-initializer</a></code>, <code><a href="#QTOOLS:DEFINE-FINALIZER">define-finalizer</a></code>, <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code>, and <code><a href="#QTOOLS:DEFINE-MENU">define-menu</a></code> that Qtools provides out of the box:</p>

<pre><code>(<a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a> (my-widget chant) (<a href="http://l1sp.org/cl/string">string</a>))

(<a href="#QTOOLS:DEFINE-SLOT">define-slot</a> (my-widget hear) ((thing string))
  (<a href="http://l1sp.org/cl/format">format</a> T &quot;I heard: ~s&quot; thing))

(<a href="#QTOOLS:DEFINE-SLOT">define-slot</a> (my-widget chant) ()
  (<a href="#QTOOLS:SIGNAL!">signal!</a> my-widget chant (&quot;MORE CODE&quot; string)))

(<a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a> (my-widget chant-button) (#_new QPushButton &quot;Chant!&quot;)
  (<a href="#QTOOLS:CONNECT!">connect!</a> chant-button (released) my-widget (chant)))
</code></pre>

<h3>The <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code></h3>

<p>Qtools provides its own version of <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>. Now, I understand and agree that usually it is a bad idea to provide alternate standard functions as it will cause confusion. Here's the trick to Qtools' version though: It will act exactly like the standard <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> (in fact, it will emit such a form) and only gives special treatment to select <code><a href="http://l1sp.org/cl/declare">declare</a></code> forms. This allows us to re-use the existing syntax that everyone already knows, but extend it by introducing new declarations, which won't clash otherwise. By default, the declarations for <code><a href="#QTOOLS:SLOT">slot</a></code>, <code><a href="#QTOOLS:OVERRIDE">override</a></code>, <code><a href="#QTOOLS:INITIALIZER">initializer</a></code>, and <code><a href="#QTOOLS:FINALIZER">finalizer</a></code> are recognised. These cause the effect that you might expect: They each modify the class the method specialises on and introduce the necessary machinery to connect the method call.</p>

<pre><code>(<a href="http://l1sp.org/cl/defmethod">defmethod</a> paint ((widget foo) paint-event)
  (<a href="http://l1sp.org/cl/declare">declare</a> (<a href="#QTOOLS:OVERRIDE">override</a> paint-event))
  ...)
</code></pre>

<p>In order to be able to use this effectively and painlessly, you should probably <code>:use</code> the extra package <code>cl+qt</code> instead of <code>cl</code> in your package. This package exports <code>cl</code>, <code>qt</code>, and <code>qtools</code> with the proper shadowing in place to use Qtools' <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>.</p>

<h3>Menu Definition</h3>

<p>As mentioned above, Qtools also offers a <code><a href="#QTOOLS:DEFINE-MENU">define-menu</a></code> macro which allows you to write menus in an extremely compact format:</p>

<pre><code>(<a href="#QTOOLS:DEFINE-MENU">define-menu</a> (my-widget File)
  (:item (&quot;Open...&quot; (ctrl o))
    (open-file))
  (:menu recent-files)
  (:separator)
  (:item (&quot;Save&quot; (ctrl s))
    (save-file))
  (:item (&quot;Save As...&quot; (ctrl alt s))
    (save-file NIL))
  (:menu &quot;Export&quot;
    (:item &quot;PNG&quot; (save-file NIL &quot;png&quot;)))
  (:separator)
  (:item (&quot;Quit&quot; (ctrl q))
    (#_close widget)))
</code></pre>

<p>In the case of items and menus, if the first argument is a symbol, it picks the object from the according slot on the widget. Otherwise it expects a string to use as text, or in the case of an item a string and a mnemonic. For items the body can be arbitrary lisp forms to be executed when the item is triggered. Menus can also be nested to arbitrary depth. All items that are created in a menu are also automatically stored in a list of QAction objects. You can retrieve this list for any class using <code><a href="#QTOOLS:WIDGET-ACTIONS">widget-actions</a></code>.</p>

<p>A frequent task is allowing the user to redefine the keyboard shortcuts of menu items. Since Qtools' <code><a href="#QTOOLS:DEFINE-MENU">define-menu</a></code> keeps track of all its items, it is easy to inspect them and change their mnemonics. However, there's also the <code><a href="#QTOOLS:KEYCHORD-EDITOR">keychord-editor</a></code> widget class, which should offer you a simple but effective dialog to change keyboard shortcuts.</p>

<h3>Readtable</h3>

<p>CommonQt provides a necessary readtable to add a convenient way to write foreign calls. Qtools provides its own named-readtable (<code>:qtools</code>) that inherits from this readtable, but adds some minor tweaks.</p>

<p>The reader macros <code>#&lt;</code> to call <code><a href="#QTOOLS:UNBOX">unbox</a></code> and <code>#&gt;</code> to call <code><a href="#QTOOLS:MAKE-GC-FINALIZED">make-gc-finalized</a></code> on the following object are available.</p>

<p>The Qtools readtable also deals with the Q+ system.</p>

<h3>Q+</h3>

<p>By default with CommonQt, calling Qt methods happens with the <code>#_</code> reader macro. This requires you to follow the proper case of the class and method names. Having this kind of mixture of conventions in the code is a bit jarring. While Qtools offers solutions to deal with the discrepancies of defining your own classes and widgets using the various <code>define-*</code> macros, Q+ fixes the method calling discrepancy. In order to use Q+ you have a choice of either using the <code><a href="#QTOOLS:Q+">q+</a></code> macro, or using the <code>:qtools</code> read-table. Using the <code><a href="#QTOOLS:Q+">q+</a></code> macro directly an example translates like this:</p>

<pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((widget (#_new QWidget)))
  (#_setWindowTitle widget &quot;Hello!&quot;)
  (#_show widget)
  (#_exec *qapplication*))

(<a href="http://l1sp.org/cl/let">let</a> ((widget (<a href="#QTOOLS:Q+">q+</a> make-qwidget)))
  (<a href="#QTOOLS:Q+">q+</a> set-window-title widget &quot;Hello!&quot;)
  (<a href="#QTOOLS:Q+">q+</a> show widget)
  (<a href="#QTOOLS:Q+">q+</a> exec *qapplication*))
</code></pre>

<p>And the same using the readtable:</p>

<pre><code>(<a href="http://l1sp.org/cl/let">let</a> ((widget (q+:make-qwidget)))
  (q+:set-window-title widget &quot;Hello!&quot;)
  (q+:show widget)
  (q+:exec *qapplication*))
</code></pre>

<p>The difference is minimal in the typed code. However, the second approach will give you the convenience of letting the editor display the possible arguments and a docstring linking to the Qt methods. The second example is read by the Common Lisp reader to the first example. There is therefore no code difference in how the two work. If you use the <code>cl+qt</code> package, you can also take advantage of an extended <code><a href="http://l1sp.org/cl/setf">setf</a></code> macro. Using it, the second line would look like so:</p>

<pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#QTOOLS:Q+">q+</a> window-title widget) &quot;Hello!&quot;)
</code></pre>

<p>Some of the setter functions require multiple values to be set at once. The updated <code><a href="http://l1sp.org/cl/setf">setf</a></code> can also deal with that:</p>

<pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#QTOOLS:Q+">q+</a> window painter) (<a href="http://l1sp.org/cl/values">values</a> 0 0 100 100))
</code></pre>

<p>The <code><a href="http://l1sp.org/cl/setf">setf</a></code> has extra support for <code><a href="#QTOOLS:Q+">q+</a></code>, but is otherwise identical to <code><a href="http://l1sp.org/cl/setf">cl:setf</a></code> and actually expands to that for all other places.</p>

<p>In order for Q+ to work seamlessly in conjunction with ASDF systems and compiling/loading code, you have to make sure that the smoke modules are set up correctly</p>

<h3>Smoke Modules</h3>

<p>CommonQt uses the SmokeQt library to interface with Qt. Smoke is divided up into different modules that provide parts of the Qt framework. In order to be able to use the various parts of Qt, these modules need to be loaded. By default CommonQt loads <code>qtcore</code> and <code>qtgui</code> when <code>make-qapplication</code> is called. However, if you want to use, say, the OpenGL parts you'll also need <code>qtopengl</code>.</p>

<p>Qtools provides ASDF systems for all the different smoke modules. That way, you can simply push the modules you want into your project's ASDF system dependencies and it'll ensure that the modules are available at compile and load time. Having the modules loaded at both times is especially important for Q+ to work properly. An example system making use of this would look like</p>

<pre><code>(asdf:defsystem foo
  ...
  :depends-on (:qtcore :qtgui))
</code></pre>

<p>For a list of available smoke modules, see <code><a href="#QTOOLS:*SMOKE-MODULES*">*smoke-modules*</a></code>.</p>

<h2>Extending Qtools</h2>

<h3>Copying and Finalizing</h3>

<p>In order to account for your own objects and operations you can extend the <code><a href="#QTOOLS:COPY">copy</a></code> and <code><a href="#QTOOLS:FINALIZE">finalize</a></code> functions by using <code><a href="#QTOOLS:DEFINE-COPY-METHOD">define-copy-method</a></code> and <code><a href="#QTOOLS:DEFINE-FINALIZE-METHOD">define-finalize-method</a></code> or <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> directly. The two define macros bring the convenience of automatically resolving to a Qt class (and thus using <code>copy/finalize-using-class</code>) if possible, making it all look a bit cleaner.</p>

<pre><code>(<a href="#QTOOLS:DEFINE-COPY-METHOD">define-copy-method</a> (instance QPixmap)
  &quot;Creates a new QPixmap using QPixmap::copy (deep copy).&quot;
  (#_copy instance (#_rect instance)))
</code></pre>

<p>Since copying and finalizing are operations associated with a certain amount of ambiguity, it is advisable to always write documentation strings for your <code><a href="#QTOOLS:COPY">copy</a></code>/<code><a href="#QTOOLS:FINALIZE">finalize</a></code> methods. That way users can get a better idea of what will happen by reading about it using <code><a href="#QTOOLS:DESCRIBE-COPY-METHOD">describe-copy-method</a></code> and <code><a href="#QTOOLS:DESCRIBE-FINALIZE-METHOD">describe-finalize-method</a></code> respectively.</p>

<h3>Adding <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> declarations</h3>

<p>Using <code><a href="#QTOOLS:DEFINE-METHOD-DECLARATION">define-method-declaration</a></code> you can add your own processing to method declarations. Your function should extract the necessary information from its declaration arguments and the <code><a href="#QTOOLS:*METHOD*">*method*</a></code> form. Each method declaration processing function should return a single form (like a macro) to be put before the resulting <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>. The existing declaration processors are really short:</p>

<pre><code>(<a href="#QTOOLS:DEFINE-METHOD-DECLARATION">define-method-declaration</a> override (&amp;optional name)
  (<a href="http://l1sp.org/cl/let">let</a> ((slot (<a href="#QTOOLS:TO-METHOD-NAME">qtools:to-method-name</a> (<a href="http://l1sp.org/cl/or">or</a> name (form-fiddle:lambda-name *method*)))))
    (with-widget-class (<a href="#QTOOLS:WIDGET-CLASS">widget-class</a>)
      `(<a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">set-widget-class-option</a> ',widget-class :override '(,slot ,name)))))
</code></pre>

<h3>Extending the menu definition</h3>

<p>The menu definition form allows for arbitrary content types, so you may add new ones yourself by using <code><a href="#QTOOLS:DEFINE-MENU-CONTENT-TYPE">define-menu-content-type</a></code>. Each content type definition can return two values: an initform and a side-form. The initform will be put into the initialization function for the menu and thus evaluated when the widget is created. The side-form is put alongside the initializer definition and thus evaluated during compilation. If your menu type needs to modify the widget class in some way, that should be done through the side-forms. If it needs to connect signals, add items, or perform similar actions that involve Qt, that should go into the initform. You can call the expansion of other component types using <code><a href="#QTOOLS:BUILD-MENU-CONTENT">build-menu-content</a></code>. During the time your content-type function is run, <code><a href="#QTOOLS:*WIDGET*">*widget*</a></code> is bound to the class-name of the widget and during initialization it is bound to the actual widget instance.</p>

<h2>Debugging Qtools</h2>

<p>Since Qtools does a bunch of contrived things, you might want to check what exactly is done if something doesn't go according to plan. I'm not excluding the possibility of bugs being around that mess your code up. In order to check this, you will want to load <a href="http://shinmera.github.io/verbose/">verbose</a> before loading Qtools and set the logging level to trace: <code>(<a href="http://l1sp.org/cl/setf">setf</a> (v:repl-level) :trace)</code>. Qtools will emit log messages when you compile <code><a href="#QTOOLS:DEFINE-WIDGET">define-widget</a></code> forms that contain the generated options. It will also log all objects that get passed to <code><a href="#QTOOLS:FINALIZE">finalize</a></code> and <code><a href="#QTOOLS:COPY">copy</a></code>. Hopefully the log output will help you in discovering what's going on behind the scenes.</p>

<h2>Qtools Concepts</h2>

<p>Qtools has grown to be a large library with a lot of rather complicated concepts. I will try to describe them here, in order to retain some information in non-code form and make things clearer to the average user. It is not necessary to read and understand this section to use Qtools, but it may be useful to be aware of the underlying ideas and functionality that make Qtools work.</p>

<h3>Finalizables</h3>

<p>A finalizable is implemented using two classes, one serving as the metaclass and the other as a superclass. The metaclass is required in order to allow a custom slot type that supports the <code>:finalized</code> argument. The superclass is necessary in order to allow methods such as <code><a href="#QTOOLS:FINALIZE">finalize</a></code> to operate on instances of the finalizable classes. The handling of the finalized slots is done through a general method on <code><a href="#QTOOLS:FINALIZE">finalize</a></code> that scans through the slots of the class instance and then calls <code><a href="#QTOOLS:FINALIZE">finalize</a></code> on each slot for which the definition is set to be <code>:finalized</code>. This makes finalization of class slots automatic and convenient.</p>

<p>Since finalizables don't add any metaclass properties, there is no need to manually calculate inheritance order. However, as with all custom slot definitions, the slot properties must be copied over from the direct-slot instance to the effective slot. In the case of <code><a href="#QTOOLS:FINALIZABLE-CLASS">finalizable-class</a></code> this happens in <code>compute-effective-slot-definition</code>.</p>

<p>In order to support finalizing of Qt class instances that don't have a CL class equivalent, the <code><a href="#QTOOLS:FINALIZE">finalize</a></code> method is extended wit ha <code><a href="#QTOOLS:FINALIZE-USING-CLASS">finalize-using-class</a></code> that is dispatched to using the Qt class and the instance of a <code>qobject</code> instance is passed to <code><a href="#QTOOLS:FINALIZE">finalize</a></code>.</p>

<h3>Widgets</h3>

<p>As with finalizables, the widget is implemented using two classes, the <code><a href="#QTOOLS:WIDGET-CLASS">widget-class</a></code> metaclass and the <code><a href="#QTOOLS:WIDGET">widget</a></code> superclass. These both inherit from the finalizable equivalents. The main crux of the <code><a href="#QTOOLS:WIDGET-CLASS">widget-class</a></code> lies in its <code><a href="#QTOOLS:WIDGET-CLASS-DIRECT-OPTIONS">widget-class-direct-options</a></code> and <code><a href="#QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS">widget-class-extern-options</a></code>. The direct options are the options that are passed to a <code>re/</code> <code><a href="http://l1sp.org/cl/initialize-instance">initialize-instance</a></code> (and thus also to <code><a href="http://l1sp.org/cl/defclass">defclass</a></code>). They're caught in the appropriately specialised methods and then stored on the class. The effect of this is that we can fully recompute the class definition at any time, and potentially add or remove options without influencing the original <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> statement. This is where the extern-options come in.</p>

<p>Using <code><a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">set-widget-class-option</a></code> options can be added to the class definition dynamically at any point in the program. This function then adds the option to the class' extern-options and then calls <code><a href="http://l1sp.org/cl/reinitialize-instance">reinitialize-instance</a></code>, which in turn causes the class to get effectively redefined outside of its <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> form. This redefinition also allows us to change CommonQt class options. Using this we can create forms outside of the original <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> that act as if they were actually options in the <code><a href="http://l1sp.org/cl/defclass">defclass</a></code> form.</p>

<p>Qtools effectively only provides two forms that do this: <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code> and <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>. The <code><a href="#QTOOLS:DEFINE-SIGNAL">define-signal</a></code> is relatively straightforward and simply expands to a class option set to add a new signal option. The <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> is an extensible machine in itself.</p>

<p>What's special about the <code>cl+qt:defmethod</code> is that it inspects the declaration forms in the method body. It then checks for each declaration form whether a handler function exist and if so, calls that function. Such a <code><a href="#QTOOLS:METHOD-DECLARATION">method-declaration</a></code> function can then return forms to be put into the macroexpansion of the <code>cl+qt:defmethod</code>, before the resulting <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code>. The processed declaration is then left out of the <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code>form as it is assumed that it isn't a standard common lisp declaration. However, the declaration function also has the ability to change the contents of the <code><a href="http://l1sp.org/cl/defmethod">cl:defmethod</a></code> form itself, by manipulating <code><a href="#QTOOLS:*METHOD*">*method*</a></code>. This allows the declaration to output special handling for the method body, for example.</p>

<p>This kind of extensible declaration mechanism is necessary both to allow further evolving of Qtools in the future as well as adaptation by users. It also offers a very &quot;native-like&quot; way of specifying external effects of a method. Qtools uses this construct then to allow definition of slots, overrides, finalizers, and initializers.</p>

<p>In case the user doesn't appreciate the <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code> way, Qtools then provides <code>define-*</code> alternative functions that simply wrap over <code><a href="http://l1sp.org/cl/defmethod">defmethod</a></code>, establish some default bindings, and take care of naming and specialising the method.</p>

<p>The <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> deserves special attention here, as it does more work than the rest. A large part of defining widgets is adding sub-components to it, which is a task that usually involves a lot of repetition or awkward function sharing: Setting up a slot to hold the instance, defining or using an initializer to set it up. <code><a href="#QTOOLS:DEFINE-SUBWIDGET">define-subwidget</a></code> makes this both distributed and simple by both taking care of setting up an appropriate initializer function, and automatically adding the slot to the class using, again, <code><a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">set-widget-class-option</a></code>. This slot is also always automatically set to be <code><a href="#QTOOLS:FINALIZED">finalized</a></code> in order to ensure that all widgets are properly cleaned up when the GUI is no longer needed.</p>

<p>A minor problem regarding this approach is the same problem that appears with all of CL's definition forms. While developing incrementally, merely removing the definition form from the source file, will not actually remove it from the image. This can trip developers up, as definitions will still be active later. In this case it means having widgets still sticking around, or initializers running, etc. For this purpose there are corresponding <code>remove-*</code> functions to all the <code>define-*</code> functions to allow easy removal. This part cannot possibly be automated due to the nature of Common Lisp, but it is at least simple to correct should the need arise.</p>

<h3>Q+</h3>

<p>CommonQt's way of dealing with method calls is the simple and most direct way of doing it. The first possible alternative to remove the need for typing method names in their corresponding case would be to simply introduce a different reader macro that automatically translates a <code>example-function</code>-like name into <code>exampleFunction</code> as is done already in other parts of Qtools. However, this has two downsides, the first being that there does not exist a 1:1 mapping of methods anywhere. The dynamic computation of the function name means that there isn't a full correspondence table anywhere. The second downside is that methods are still not passable as first-class objects.</p>

<p>The way to solve this is to generate actual CL wrapper functions to the method calls. This allows us to use them as first-class objects, have at least compile-time argument number checking, and have a linkage of wrapper name to Qt method by listing it in the docstring.</p>

<p>In order to achieve this, there are two possible choices. First, the entirety of all possible wrappers can be computed once, and then subsequently loaded into the image and used directly. However, this creates two new problems. Computing all wrappers, compiling them, and loading them, takes a long time and subsequently litters the image with thousands of functions and symbols that won't ever be used in the program. Then, we have a problem with the smoke modules, as we need to know which modules will be used in a potential application ahead of time, load them all, and then generate the wrappers. We cannot generate wrappers for each module separately, as the methods from different classes share the same wrapper functions. This means that whenever a different set of modules is needed, the wrappers need to be regenerated, recompiled, and reloaded. A lot of time and space goes to waste with this. However, this approach also has an advantage: As all functions are always available, it is easy to develop with. Arguments and docstrings will be readily available through the editor. Qtools offers this approach through <code><a href="#QTOOLS:Q+-COMPILE-AND-LOAD">q+-compile-and-load</a></code>.</p>

<p>The second approach is to dynamically only compile what is needed. That way, the image only ever contains wrappers for function that are actually called (at some point). However, this complicates things a lot. When a function is compiled that calls such a function, it doesn't exist yet. Even worse, when the form is read, the symbol for the function does not exist yet and isn't external! In order to catch this problem, a modified reader macro is necessary. This reader macro will detect when a call to a wrapper function is made, and instead transform it into a macro call that then sees to it that the wrapper will be created. Modifying the reader in such a way is a heavy change, and should only be used sparingly, however there is no alternative here. Qtools does not force you to use this reader extension, you can always just use the macro directly.</p>

<p>However, dynamic compilation complications don't end there. Since we never dump the function to a file, it only ever exists in the environment it was compiled in. That means, if you compile a function that then dynamically generates the wrapper function, the wrapper won't be available anymore at load time. Qtools solves this issue with a trick. The <code><a href="#QTOOLS:Q+">q+</a></code> macro expands to a <code><a href="http://l1sp.org/cl/load-time-value">load-time-value</a></code> form that then generates the wrapper function. That way, the wrapper will always be available at load- and execution time, while posing no overhead to the execution time, as it will return a value to that won't impact anything.</p>

<p>Function referencing gets the same problems as function calling, so the Qtools readtable also contains an overridden <code>#'</code> reader macro to handle that. In the case of a wrapper call, it expands to <code><a href="#QTOOLS:Q+FUN">Q+FUN</a></code> which in turn expands to a <code><a href="http://l1sp.org/cl/load-time-value">load-time-value</a></code> form that generates and returns the function object.</p>

<p>As is probably obvious by now, Qtools also implements the second approach. Therefore, the choice as a user is yours: You can statically precompile everything and use it directly, or you an use the dynamic on the fly compilation using either a readtable expansion, or a simple macro. The concepts to make this all possible are rather complex, but the actual function wrapper compilations are quite straight-forward. The system is currently not suited for extension, but I see no need to allow that as the kind of Qt methods that can exist are fixed and Q+ should handle all that are relevant.</p>

<p>Q+ does one last thing to fix the &quot;issue&quot; of having setters instead of being able to use <code><a href="http://l1sp.org/cl/setf">setf</a></code>. For this purpose it has an extended <code><a href="http://l1sp.org/cl/setf">setf</a></code> macro that checks if a place is a function in the Q+ package. if so, this place/value pair is instead expanded to a call to the appropriate wrapper function with the function name transformed. However, that's not the only reason to do this. The second is that some setters require multiple arguments to be set at once. Usually, <code><a href="http://l1sp.org/cl/setf">cl:setf</a></code> allows for cases like these by permitting setf expanders to accept multiple values. However, the number of values is fixed, and there's no way to dynamically know how many values where passed. Since Q+ needs to dispatch based on the number of values, this is not a viable approach. Therefore, with <code>cl+qt:setf</code> a <code>(<a href="http://l1sp.org/cl/values">values</a> ..)</code> value form is specially treated and its arguments are inlined into the wrapper call. This also means that it isn't possible to use multiple values of a returning function as the values to a setter call, however while that is an inconsistency, I don't think it will be a big issue. If it turns out to be problematic in the later run, this will have to be changed to a dynamic analysis at run-time, which is an overhead I wanted to avoid.</p>

<p>One final note about the dynamic approach and its readtable: In order to recognise whether a call to a symbol in the Q+ package is made, it needs to read ahead multiple symbols and call <code><a href="http://l1sp.org/cl/unread-char">unread-char</a></code> multiple times consecutively, if it turns out that it is not a Q+ reference. Multiple consecutive calls to <code><a href="http://l1sp.org/cl/unread-char">unread-char</a></code> are not permitted by the hyperspec, so a different approach should be found eventually. Right now, this is an unresolved kludge and I will see about fixing it once it causes real problems.</p>

<h2>Support</h2>

<p>Currently the following implementations are tested and supported by Qtools:</p>

<ul>
<li><a href="http://www.sbcl.org/">SBCL</a> (1.2.8 Lin64)</li>
<li><a href="http://ccl.clozure.com/">CCL</a> (1.10 Lin64)</li>
</ul>

<p>It may or may not work more or less smoothly on other implementations and platforms depending on MOP and CommonQt support and general implementation quirks.</p>
</span>
        </c:documentate>
      </article>
      <article>
        <h2>Copyright</h2>
        <span>qtools</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license and Â©<span>2015</span> <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span>. This library can be obtained on <a href="https://github.com/Shinmera/qtools">https://github.com/Shinmera/qtools</a>.
      </article>
      <article id="symbol-index">
        <h2>Package Index</h2>
        <ul><li class="package">
            <h3>
              <a name="QTOOLS" href="#QTOOLS">QTOOLS</a>
              <span class="nicknames">(ORG.SHIRAKUMO.QTOOLS)</span>
            </h3>
            <ul><li>
                <a name="QTOOLS:FINALIZABLE"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:FINALIZABLE">FINALIZABLE</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>A class for finalizable objects.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FINALIZABLE-CLASS"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:FINALIZABLE-CLASS">FINALIZABLE-CLASS</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Metaclass for classes with finalizable slots.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FINALIZABLE-SLOT"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:FINALIZABLE-SLOT">FINALIZABLE-SLOT</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Superclass for slots with a finalized option.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:GC-FINALIZED"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:GC-FINALIZED">GC-FINALIZED</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Wrapper object to allow automatic calling of FINALIZE by the GC.
Since you cannot finalize the object that is GC-ed itself, we need to wrap our to-
be-finalized object in another object that takes all the references instead.

This means that if you wish your object to remain unfinalized, you need to retain
references to the wrapper. As soon as the wrapper is hit by the GC, FINALIZE is
called on the object it contains.

In order to retrieve the contained object, use UNBOX.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:KEYCHORD-EDITOR"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:KEYCHORD-EDITOR">KEYCHORD-EDITOR</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre/>
                </article>
              </li><li>
                <a name="QTOOLS:SMOKE-MODULE-SYSTEM"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:SMOKE-MODULE-SYSTEM">SMOKE-MODULE-SYSTEM</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>A wrapper ASDF system class that only exists to ensure that a
given smoke module is loaded at compile and load time.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET">WIDGET</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Common superclass for all widgets in order to allow for
general initialization and cleanup forms that are standardised across all
widgets. 

See QTOOLS:DEFINE-WIDGET.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET-CLASS"/>
                <article>
                  <header>
                    <span>CLASS</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET-CLASS">WIDGET-CLASS</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Metaclass for widgets storing necessary information.

The metadata stored in this is mostly responsible for two things:
 1) Providing access to a sequence of mutually independent
    initializers and finalizers for convenient setup and cleanup.
 2) Allowing after-the-fact out-of-form changes to the class
    definition, which is necessary to have for a distributed
    definition form syntax as provided by WIDGET-CONVENIENCE macros.
In order to modify the metadata, please look at SET/REMOVE-WIDGET-CLASS-OPTION.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:BUILD-MENU-CONTENT"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:BUILD-MENU-CONTENT">BUILD-MENU-CONTENT</a></h4>
                      <span/>
                      <span>(PARENT TYPE CONTENTS)</span>
                    </code>
                  </header>
                  <pre>Calls the appropriate function to parse menu content of TYPE.

See (SETF QTOOLS:MENU-CONTENT-TYPE).</pre>
                </article>
              </li><li>
                <a name="QTOOLS:CALL-FINALIZERS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:CALL-FINALIZERS">CALL-FINALIZERS</a></h4>
                      <span/>
                      <span>(CLASS)</span>
                    </code>
                  </header>
                  <pre>Calls all the finalizers specified on CLASS in their proper sequence.

CLASS can be either an instance of a WIDGET-CLASS, a
WIDGET-CLASS itself, or a symbol naming the class.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:CALL-INITIALIZERS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:CALL-INITIALIZERS">CALL-INITIALIZERS</a></h4>
                      <span/>
                      <span>(CLASS)</span>
                    </code>
                  </header>
                  <pre>Calls all the initializers specified on CLASS in their proper sequence.

CLASS can be either an instance of a WIDGET-CLASS, a
WIDGET-CLASS itself, or a symbol naming the class.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:CAPITALIZE-ON"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:CAPITALIZE-ON">CAPITALIZE-ON</a></h4>
                      <span/>
                      <span>(CHARACTER STRING &amp;OPTIONAL (REPLACEMENT CHARACTER) START-CAPITALIZED)</span>
                    </code>
                  </header>
                  <pre/>
                </article>
              </li><li>
                <a name="QTOOLS:CL-TYPE-FOR"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:CL-TYPE-FOR">CL-TYPE-FOR</a></h4>
                      <span/>
                      <span>(QT-TYPE)</span>
                    </code>
                  </header>
                  <pre>Attempts to determine the CL type for the given Qt type descriptor.

Look at the source to see the mappings.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:CLEAR-LAYOUT"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:CLEAR-LAYOUT">CLEAR-LAYOUT</a></h4>
                      <span/>
                      <span>(LAYOUT)</span>
                    </code>
                  </header>
                  <pre>Removes all widgets from the layout and returns them as a list.
It does not do anything with the widgets themselves.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:CLEAR-METHOD-INFO"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:CLEAR-METHOD-INFO">CLEAR-METHOD-INFO</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Clears the *QMETHODS* table.

See QTOOLS:*QMETHODS*</pre>
                </article>
              </li><li>
                <a name="QTOOLS:COMPILE-WRAPPER"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:COMPILE-WRAPPER">COMPILE-WRAPPER</a></h4>
                      <span/>
                      <span>(METHOD)</span>
                    </code>
                  </header>
                  <pre>Compiles the wrapper function for METHOD.

This does not actually call CL:COMPILE, or change
the global environment in any way. It instead returns
a form that you can then truly compile, print, or write
to file, or whatever your intention is.

See QTOOLS:ENSURE-METHODS
See QT:QMETHOD-ENUM-P
See QTOOLS:COMPILE-CONSTANT
See QT:QMETHOD-CTOR-P
See QT:QMETHOD-COPYCTOR-P
See QTOOLS:COMPILE-CONSTRUCTOR
See QTOOLS:QMETHOD-OPERATOR-P
See QTOOLS:COMPILE-OPERATOR
See QT:QMETHOD-STATIC-P
See QTOOLS:COMPILE-STATIC-METHOD
See QTOOLS:COMPILE-METHOD</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DESCRIBE-COPY-METHOD"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:DESCRIBE-COPY-METHOD">DESCRIBE-COPY-METHOD</a></h4>
                      <span/>
                      <span>(CLASS)</span>
                    </code>
                  </header>
                  <pre>Prints information about the copy method for the specified class if possible.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DESCRIBE-FINALIZE-METHOD"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:DESCRIBE-FINALIZE-METHOD">DESCRIBE-FINALIZE-METHOD</a></h4>
                      <span/>
                      <span>(CLASS)</span>
                    </code>
                  </header>
                  <pre>Prints information about the finalize method for the given class if possible.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DETERMINED-TYPE-METHOD-NAME"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:DETERMINED-TYPE-METHOD-NAME">DETERMINED-TYPE-METHOD-NAME</a></h4>
                      <span/>
                      <span>#'ARGS</span>
                    </code>
                  </header>
                  <pre>Returns a method designator for the FUNCTION and ARGS.

The FUNCTION is transformed as by TO-METHOD-NAME.
Argument types are determined as follows:
If the argument is a CONS, the CAR is taken as a value (and thus discarded)
and the CDR is the literal type to take. Otherwise the type is determined
by EQT-TYPE-OF.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:ECL-TYPE-FOR"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:ECL-TYPE-FOR">ECL-TYPE-FOR</a></h4>
                      <span/>
                      <span>(QT-TYPE)</span>
                    </code>
                  </header>
                  <pre>Same as CL-TYPE-FOR, but signals an error if no matching type could be found.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:ENSURE-CLASS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:ENSURE-CLASS">ENSURE-CLASS</a></h4>
                      <span/>
                      <span>(THING)</span>
                    </code>
                  </header>
                  <pre>Ensures to return a CLASS.
SYMBOL -&gt; FIND-CLASS
CLASS  -&gt; IDENTITY
STANDARD-OBJECT -&gt; CLASS-OF</pre>
                </article>
              </li><li>
                <a name="QTOOLS:ENSURE-METHODS-PROCESSED"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:ENSURE-METHODS-PROCESSED">ENSURE-METHODS-PROCESSED</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Ensures that all methods have been generated for the currently loaded smoke modules.

See QTOOLS:LOADED-SMOKE-MODULES
See QTOOLS:*GENERATED-MODULES*
See QTOOLS:PROCESS-ALL-METHODS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:ENSURE-Q+-METHOD"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:ENSURE-Q+-METHOD">ENSURE-Q+-METHOD</a></h4>
                      <span/>
                      <span>(FUNCTION)</span>
                    </code>
                  </header>
                  <pre>Ensures that the Q+ FUNCTION exists by compiling it on the fly.
Raises an error if no appropriate function can be found.
Returns the proper *TARGET-PACKAGE* symbol for the function.

See QTOOLS:ENSURE-METHODS-PROCESSED
See QTOOLS:COMPILE-WRAPPER
See QTOOLS:*TARGET-PACKAGE*</pre>
                </article>
              </li><li>
                <a name="QTOOLS:ENUMERATE-METHOD-DESCRIPTORS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:ENUMERATE-METHOD-DESCRIPTORS">ENUMERATE-METHOD-DESCRIPTORS</a></h4>
                      <span/>
                      <span>(NAME ARGS)</span>
                    </code>
                  </header>
                  <pre>Returns a list of all possible method descriptors with NAME and ARGS.
Args may be either a list of direct types to use or a list of alternative types.
In the case of lists, the argument alternatives are taken in parallel.

Examples: 
 (.. foo '(a b)) =&gt; (&quot;foo(a,b)&quot;)
 (.. foo '((a b))) =&gt; (&quot;foo(a)&quot; &quot;foo(b)&quot;)
 (.. foo '((a b) (0 1))) =&gt; (&quot;foo(a,0)&quot; &quot;foo(b,1)&quot;)</pre>
                </article>
              </li><li>
                <a name="QTOOLS:EQT-CLASS-NAME"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:EQT-CLASS-NAME">EQT-CLASS-NAME</a></h4>
                      <span/>
                      <span>(DESIGNATOR)</span>
                    </code>
                  </header>
                  <pre>Returns the string designating an equivalent Qt class, if possible.
If the designator is a string, it is returned immediately without further check.
If it is a symbol, it is resolved through FIND-QT-CLASS-NAME, and if no name can
be found through that, an error is signalled.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:EQT-TYPE-OF"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:EQT-TYPE-OF">EQT-TYPE-OF</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Same as QT-TYPE-OF, but signals an error if no matching type could be found.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FIND-QT-CLASS-NAME"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:FIND-QT-CLASS-NAME">FIND-QT-CLASS-NAME</a></h4>
                      <span/>
                      <span>(DESIGNATOR)</span>
                    </code>
                  </header>
                  <pre>Returns the string designating an equivalent Qt class. You can use this to resolve
symbols and 'lisp-ified' names to Qt class names. Hyphens are stripped from the designator.

See *QT-CLASS-MAP*</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FUSE-ALISTS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:FUSE-ALISTS">FUSE-ALISTS</a></h4>
                      <span/>
                      <span>(&amp;REST ALISTS-LISTS)</span>
                    </code>
                  </header>
                  <pre/>
                </article>
              </li><li>
                <a name="QTOOLS:FUSE-PLISTS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:FUSE-PLISTS">FUSE-PLISTS</a></h4>
                      <span/>
                      <span>(&amp;REST PLISTS-LISTS)</span>
                    </code>
                  </header>
                  <pre/>
                </article>
              </li><li>
                <a name="QTOOLS:GENERIC-SIGNAL"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:GENERIC-SIGNAL">GENERIC-SIGNAL</a></h4>
                      <span/>
                      <span>(OBJECT FUNCTION &amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Attempts to signal the function FUNCTION on OBJECT by determining the
types according to the run-time types of the values.

This is SLOW as the signal method has to be determined at run-time and it
is DANGEROUS as the type mapping are ambiguous or even unknown for certain
arguments and as such the wrong signal may be called or even one that does
not actually exist. If you want to explicitly specify the type of the
argument, wrap it in a CONS where the CAR is the value and the CDR is a
string for the according Qt type.

A compiler macro will try to statically determine types as best as possible,
so GENERIC-SIGNAL is save to use for static values.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:LOAD-ALL-SMOKE-MODULES"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:LOAD-ALL-SMOKE-MODULES">LOAD-ALL-SMOKE-MODULES</a></h4>
                      <span/>
                      <span>(&amp;REST MODS)</span>
                    </code>
                  </header>
                  <pre>Loads all the smoke modules as passed.

See QT:ENSURE-SMOKE</pre>
                </article>
              </li><li>
                <a name="QTOOLS:LOADED-SMOKE-MODULES"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:LOADED-SMOKE-MODULES">LOADED-SMOKE-MODULES</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Returns a fresh list of currently loaded smoke modules.

See QTOOLS:*SMOKE-MODULES*
See QT:NAMED-MODULE-NUMBER</pre>
                </article>
              </li><li>
                <a name="QTOOLS:MAKE-CHORD"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:MAKE-CHORD">MAKE-CHORD</a></h4>
                      <span/>
                      <span>(CHORD)</span>
                    </code>
                  </header>
                  <pre>Transforms CHORD into a keychord string, if possible.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:MAKE-GC-FINALIZED"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:MAKE-GC-FINALIZED">MAKE-GC-FINALIZED</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Wrap the OBJECT in a GC-FINALIZED instance. Use UNBOX to retrieve the object again.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:MAP-COMPILE-ALL"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:MAP-COMPILE-ALL">MAP-COMPILE-ALL</a></h4>
                      <span/>
                      <span>(FUNCTION)</span>
                    </code>
                  </header>
                  <pre>Calls FUNCTION with the result of COMPILE-WRAPPER on all available methods.

See QTOOLS:COMPILE-WRAPPER
See QTOOLS:*QMETHODS*</pre>
                </article>
              </li><li>
                <a name="QTOOLS:MAYBE-DELETE-QOBJECT"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:MAYBE-DELETE-QOBJECT">MAYBE-DELETE-QOBJECT</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Deletes the object if possible.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:MENU-CONTENT-TYPE"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:MENU-CONTENT-TYPE">MENU-CONTENT-TYPE</a></h4>
                      <span/>
                      <span>(NAME)</span>
                    </code>
                  </header>
                  <pre>Returns the function to process a menu content type NAME, if any.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:METHOD-DECLARATION"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:METHOD-DECLARATION">METHOD-DECLARATION</a></h4>
                      <span/>
                      <span>(NAME)</span>
                    </code>
                  </header>
                  <pre>Returns a function to process the method declaration NAME, if one exists.

See (SETF QTOOLS:METHOD-DECLARATION).</pre>
                </article>
              </li><li>
                <a name="QTOOLS:METHOD-SYMBOL"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:METHOD-SYMBOL">METHOD-SYMBOL</a></h4>
                      <span/>
                      <span>(METHOD)</span>
                    </code>
                  </header>
                  <pre>Returns an appropriate symbol to use for the name of the wrapper function for METHOD.

See QT:QMETHOD-ENUM-P
See QTOOLS:CL-CONSTANT-NAME
See QT:QMETHOD-CTOR-P
See QT:QMETHOD-COPYCTOR-P
See QTOOLS:CL-CONSTRUCTOR-NAME
See QTOOLS:QMETHOD-OPERATOR-P
See QTOOLS:CL-OPERATOR-NAME
See QT:QMETHOD-STATIC-P
See QTOOLS:CL-STATIC-METHOD-NAME
See QTOOLS:CL-METHOD-NAME</pre>
                </article>
              </li><li>
                <a name="QTOOLS:PROCESS-ALL-METHODS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:PROCESS-ALL-METHODS">PROCESS-ALL-METHODS</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Clears the method table and generates all possible data for the currently available methods.
This also sets the *GENERATED-MODULES* to the proper value.

See QT:MAP-METHODS
See QTOOLS:PROCESS-METHOD
See QTOOLS:CLEAR-METHOD-INFO
See QTOOLS:*GENERATED-MODULES*
See QTOOLS:LOADED-SMOKE-MODULES</pre>
                </article>
              </li><li>
                <a name="QTOOLS:PROCESS-METHOD"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:PROCESS-METHOD">PROCESS-METHOD</a></h4>
                      <span/>
                      <span>(METHOD)</span>
                    </code>
                  </header>
                  <pre>Push the given METHOD onto its appropriate place in the method table, if it is needed.

See QTOOLS:METHOD-NEEDED-P
See QTOOLS:METHOD-SYMBOL
See QTOOLS:*QMETHODS*</pre>
                </article>
              </li><li>
                <a name="QTOOLS:Q+-COMPILE-AND-LOAD"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:Q+-COMPILE-AND-LOAD">Q+-COMPILE-AND-LOAD</a></h4>
                      <span/>
                      <span>(&amp;KEY MODULES (FILE (MERGE-PATHNAMES q+.lisp (TEMPORARY-DIRECTORY))))</span>
                    </code>
                  </header>
                  <pre>Writes, compiles, and loads the file for all generated Qt wrapper functions.
If MODULES is passed, CommonQt is reloaded and only the given modules are loaded.

See WRITE-EVERYTHING-TO-FILE</pre>
                </article>
              </li><li>
                <a name="QTOOLS:QOBJECT-ALIVE-P"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:QOBJECT-ALIVE-P">QOBJECT-ALIVE-P</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Returns T if the object is not null and not deleted.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:QT-TYPE-FOR"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:QT-TYPE-FOR">QT-TYPE-FOR</a></h4>
                      <span/>
                      <span>(CL-TYPE)</span>
                    </code>
                  </header>
                  <pre>Attempts to determine the proper Qt type descriptor for the passed cl type name.

Look at the source to see the mappings.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:QT-TYPE-OF"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:QT-TYPE-OF">QT-TYPE-OF</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Attempts to determine a proper Qt type descriptor for the type of the OBJECT.

Look at the source to see the mappings.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-FINALIZER"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-FINALIZER">REMOVE-FINALIZER</a></h4>
                      <span/>
                      <span>(WIDGET-CLASS FINALIZER)</span>
                    </code>
                  </header>
                  <pre>Removes the FINALIZER definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See QTOOLS:REMOVE-WIDGET-CLASS-OPTION
See QTOOLS:ENSURE-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-INITIALIZER"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-INITIALIZER">REMOVE-INITIALIZER</a></h4>
                      <span/>
                      <span>(WIDGET-CLASS INITIALIZER)</span>
                    </code>
                  </header>
                  <pre>Removes the INITIALIZER definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See QTOOLS:REMOVE-WIDGET-CLASS-OPTION
See QTOOLS:ENSURE-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-MENU-CONTENT-TYPE"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-MENU-CONTENT-TYPE">REMOVE-MENU-CONTENT-TYPE</a></h4>
                      <span/>
                      <span>(NAME)</span>
                    </code>
                  </header>
                  <pre>Removes the menu content type NAME.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-METHOD-DECLARATION"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-METHOD-DECLARATION">REMOVE-METHOD-DECLARATION</a></h4>
                      <span/>
                      <span>(NAME)</span>
                    </code>
                  </header>
                  <pre>Remove the method declaration processor function of NAME.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-OVERRIDE"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-OVERRIDE">REMOVE-OVERRIDE</a></h4>
                      <span/>
                      <span>(WIDGET-CLASS OVERRIDE)</span>
                    </code>
                  </header>
                  <pre>Removes the OVERRIDE definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the override.

See QTOOLS:REMOVE-WIDGET-CLASS-OPTION
See QTOOLS:ENSURE-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-SIGNAL"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-SIGNAL">REMOVE-SIGNAL</a></h4>
                      <span/>
                      <span>(WIDGET-CLASS SIGNAL)</span>
                    </code>
                  </header>
                  <pre>Removes the SIGNAL definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See QTOOLS:REMOVE-WIDGET-CLASS-OPTION
See QTOOLS:ENSURE-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-SLOT"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-SLOT">REMOVE-SLOT</a></h4>
                      <span/>
                      <span>(WIDGET-CLASS SLOT)</span>
                    </code>
                  </header>
                  <pre>Removes the SLOT definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the slot.

See QTOOLS:REMOVE-WIDGET-CLASS-OPTION
See QTOOLS:ENSURE-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-SUBWIDGET"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-SUBWIDGET">REMOVE-SUBWIDGET</a></h4>
                      <span/>
                      <span>(WIDGET-CLASS SUBWIDGET)</span>
                    </code>
                  </header>
                  <pre>Removes the SUBWIDGET definition from the WIDGET-CLASS.

Note that this does not remove eventual methods associated with the subwidget.
It does however remove the class-slot and initializer of the subwidget.

See QTOOLS:REMOVE-WIDGET-CLASS-OPTION
See QTOOLS:ENSURE-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:REMOVE-WIDGET-CLASS-OPTION"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:REMOVE-WIDGET-CLASS-OPTION">REMOVE-WIDGET-CLASS-OPTION</a></h4>
                      <span/>
                      <span>(CLASS OPTION IDENTIFIER &amp;KEY (KEY #'FIRST) (TEST #'EQUAL))</span>
                    </code>
                  </header>
                  <pre>Removes a CLASS OPTION value.

The value is identified and distinguished within the OPTION list
by TEST on KEY. If the first item in the sub-list is EQUAL to IDENTIFIER,
it is removed. This causes a call to SOFTLY-REDEFINE-WIDGET-CLASS.

See QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS.
See QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:SET-WIDGET-CLASS-OPTION"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:SET-WIDGET-CLASS-OPTION">SET-WIDGET-CLASS-OPTION</a></h4>
                      <span/>
                      <span>(CLASS OPTION VALUE &amp;KEY (KEY #'FIRST) (TEST #'EQUAL))</span>
                    </code>
                  </header>
                  <pre>Sets a CLASS OPTION VALUE.

The value is identified and distinguished within the OPTION list
by TEST on KEY. If a matching list can be found, it is replaced
at the same position. Otherwise it is appended to the end of the
list. The order here is important to preserve load-order.

See QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS.
See QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:SOFTLY-REDEFINE-WIDGET-CLASS">SOFTLY-REDEFINE-WIDGET-CLASS</a></h4>
                      <span/>
                      <span>(CLASS)</span>
                    </code>
                  </header>
                  <pre>Cause a soft redefinition of the given CLASS.

This will in effect cause a call to REINITIALIZE-INSTANCE with the proper
class options added from WIDGET-CLASS-DIRECT-OPTIONS, followed by a
FINALIZE-INHERITANCE call on the class.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:SPECIFIED-TYPE-METHOD-NAME"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:SPECIFIED-TYPE-METHOD-NAME">SPECIFIED-TYPE-METHOD-NAME</a></h4>
                      <span/>
                      <span>#'ARGS</span>
                    </code>
                  </header>
                  <pre>Returns a method designator for the FUNCTION and ARGS.

The FUNCTION is transformed as by TO-METHOD-NAME. Each argument type is
determined as by TO-TYPE-NAME.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:SPLIT"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:SPLIT">SPLIT</a></h4>
                      <span/>
                      <span>(LIST ITEMS &amp;KEY (KEY #'IDENTITY) (TEST #'EQL))</span>
                    </code>
                  </header>
                  <pre>Segregates items in LIST into separate lists if they mach an item in ITEMS.
The first item in the returned list is the list of unmatched items.

Example:
 (split '((0 a) (0 b) (1 a) (1 b) (2 c)) '(0 2) :key #'car)
 =&gt; '(((1 a) (1 b)) ((0 a) (0 b)) ((2 c))) </pre>
                </article>
              </li><li>
                <a name="QTOOLS:TO-METHOD-NAME"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:TO-METHOD-NAME">TO-METHOD-NAME</a></h4>
                      <span/>
                      <span>(THING)</span>
                    </code>
                  </header>
                  <pre>Turns THING into a Qt method name.
If THING is a STRING, it is returned directly.
If THING is a SYMBOL, it is transformed by turning each
character after a hyphen into its uppercase equivalent
and dropping the hyphen. Therefore: foo-bar fooBar</pre>
                </article>
              </li><li>
                <a name="QTOOLS:TO-TYPE-NAME"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:TO-TYPE-NAME">TO-TYPE-NAME</a></h4>
                      <span/>
                      <span>(THING)</span>
                    </code>
                  </header>
                  <pre>Returns the type name for THING.

If THING is a string, it is returned directly.
If it is a symbol, either QT-TYPE-FOR for THING is
returned, or the STRING-DOWNCASE of THING.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET-ACTIONS"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET-ACTIONS">WIDGET-ACTIONS</a></h4>
                      <span/>
                      <span>(CLASS)</span>
                    </code>
                  </header>
                  <pre>Returns a list of QAction instances that are active on the given CLASS.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WRITE-EVERYTHING-TO-FILE"/>
                <article>
                  <header>
                    <span>FUNCTION</span>
                    <code>
                      <h4><a href="#QTOOLS:WRITE-EVERYTHING-TO-FILE">WRITE-EVERYTHING-TO-FILE</a></h4>
                      <span/>
                      <span>(PATHNAME &amp;KEY (PACKAGE *TARGET-PACKAGE*) (IF-EXISTS SUPERSEDE))</span>
                    </code>
                  </header>
                  <pre>Writes all compileable Qt method wrappers to PATHNAME.

PACKAGE designates in which package the symbols will live.
This makes it possible to deviate from the standard of
*TARGET-PACKAGE*. The value of QTOOLS:*TARGET-PACKAGE*
will be automatically set to this once the resulting file
is LOADed or compiled again.

See QTOOLS:WRITE-FORMS
See QTOOLS:*TARGET-PACKAGE*</pre>
                </article>
              </li><li>
                <a name="QTOOLS:COPY"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:COPY">COPY</a></h4>
                      <span/>
                      <span>(INSTANCE)</span>
                    </code>
                  </header>
                  <pre>Generates a copy of the object.

The way objects are copied varies, but usually it can be assumed that the
copy is made in a way such that data immediately associated with the object
is copied (such as pixel data in an image), but data only implicitly
referenced (such as the paint device of a painter) is not.

Use DESCRIBE-COPY-METHOD for information on a specific copying mechanism.

Uses COPY-QOBJECT-USING-CLASS and determines the class by QT::QOBJECT-CLASS.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:COPY-USING-CLASS"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:COPY-USING-CLASS">COPY-USING-CLASS</a></h4>
                      <span/>
                      <span>(QCLASS INSTANCE)</span>
                    </code>
                  </header>
                  <pre>Creates a copy of the given instance by using methods
appropriate for the given qclass.

See COPY</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FINALIZE"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:FINALIZE">FINALIZE</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Finalizes the object. The effects thereof may vary and even result in nothing at all.
After FINALIZE has been called on an object, it should not be attempted to be used in any fashion
whatsoever as it may have been rendered unusable or unstable.

This method should be called on any object once it is known that it can be discarded.
FINALIZE will then try to clean up objects and make sure that they don't clutter your
memory, as lingering QOBJECTs would.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FINALIZE-USING-CLASS"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:FINALIZE-USING-CLASS">FINALIZE-USING-CLASS</a></h4>
                      <span/>
                      <span>(CLASS OBJECT)</span>
                    </code>
                  </header>
                  <pre>Extension to the FINALIZE generic function to support differentiating by the
classes of an object, mostly used for native QObjects as they don't integrate into CLOS directly.
You need to use EQL specializers on the class, as a Qt class is represented as an integer.

E.g: (defmethod finalize-using-class ((class (eql (find-class &quot;QWidget&quot;))) object) ..)

This method should not be called directly.

See FINALIZE</pre>
                </article>
              </li><li>
                <a name="QTOOLS:FINALIZED"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:FINALIZED">FINALIZED</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre/>
                </article>
              </li><li>
                <a name="QTOOLS:UNBOX"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:UNBOX">UNBOX</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre/>
                </article>
              </li><li>
                <a name="QTOOLS:VALUE"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:VALUE">VALUE</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Returns the VALUE of object. This usually translates to (#_value object) unless overriden.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET-CLASS-DIRECT-OPTIONS"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET-CLASS-DIRECT-OPTIONS">WIDGET-CLASS-DIRECT-OPTIONS</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Contains all the options passed to RE/INITIALIZE-INSTANCE when
the class is re/initialized directly through a DEFCLASS form.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET-CLASS-EXTERN-OPTIONS">WIDGET-CLASS-EXTERN-OPTIONS</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>Contains all the options that are added to the class definition
through external forms and thus need to be included and kept separate
from options directly specified in the class definition.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET-CLASS-FINALIZERS"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET-CLASS-FINALIZERS">WIDGET-CLASS-FINALIZERS</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>A sorted list of functions to be called upon finalization.
This list is overwritten completely whenever the class is re/initialized.

See QTOOLS:CALL-FINALIZERS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WIDGET-CLASS-INITIALIZERS"/>
                <article>
                  <header>
                    <span>GENERIC</span>
                    <code>
                      <h4><a href="#QTOOLS:WIDGET-CLASS-INITIALIZERS">WIDGET-CLASS-INITIALIZERS</a></h4>
                      <span/>
                      <span>(OBJECT)</span>
                    </code>
                  </header>
                  <pre>A sorted list of functions to be called upon initialization.
This list is overwritten completely whenever the class is re/initialized.

See QTOOLS:CALL-INITIALIZERS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:CONNECT!"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:CONNECT!">CONNECT!</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Macro for a more lisp-y writing of CONNECT.
ORIGIN-FUNCTION and TARGET-FUNCTION should both be a list of the METHOD-NAME
followed by Qt argument types. The effective method name is computed as per
SPECIFIED-TYPE-METHOD-NAME.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-COPY-METHOD"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-COPY-METHOD">DEFINE-COPY-METHOD</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a method to copy an object of CLASS.
CLASS can be either a common-lisp class type or a Qt class name.

Qt class names will take precedence, meaning that if CLASS resolves
to a name using FIND-QT-CLASS-NAME a COPY-QOBJECT-USING-CLASS method
is defined on the respective qt-class. Otherwise a COPY-QOBJECT method
is defined with the CLASS directly as specializer for the instance.

In cases where you need to define a method on a same-named CL class,
directly use DEFMETHOD on COPY-QOBJECT.

See COPY-QOBJECT, COPY-QOBJECT-USING-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-FINALIZABLE"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-FINALIZABLE">DEFINE-FINALIZABLE</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Shorthand around DEFCLASS to create a finalizable class.

Automatically adds FINALIZABLE as direct-superclass and 
FINALIZABLE-CLASS as metaclass.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-FINALIZE-METHOD"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-FINALIZE-METHOD">DEFINE-FINALIZE-METHOD</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a method to finalize an object of CLASS.
CLASS can be either a common-lisp class type or a Qt class name.

Qt class names will take precedence, meaning that if CLASS resolves
to a name using FIND-QT-CLASS-NAME a COPY-QOBJECT-USING-CLASS method
is defined on the respective qt-class. Otherwise a COPY-QOBJECT method
is defined with the CLASS directly as specializer for the instance.

In cases where you need to define a method on a same-named CL class,
directly use DEFMETHOD on FINALIZE.

See FINALIZE, FINALIZE-USING-CLASS</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-FINALIZER"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-FINALIZER">DEFINE-FINALIZER</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a new finalizer of METHOD-NAME on WIDGET-CLASS.

Finalizers are functions that are run immediately after the widget has been
FINALIZED, but before the main FINALIZE method kicks in. This means that the
widget will still be allocated at the time. Finalizers are executed in order 
of highest PRIORITY first. 

This is translated to a method definition specialised (and bound) on WIDGET-CLASS
with a FINALIZER declaration. The BODY is wrapped in a WITH-SLOTS-BOUND form.

See CL+QT:DEFMETHOD
See QTOOLS:WITH-SLOTS-BOUND
See QTOOLS:FINALIZE</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-INITIALIZER"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-INITIALIZER">DEFINE-INITIALIZER</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a new initializer of METHOD-NAME on WIDGET-CLASS.

Initializers are functions that are run immediately after the widget has been
allocated by QT:NEW, but before any INITIALIZE-INSTANCE:AFTER methods are
executed. They are executed in order of highest PRIORITY first. 

This is translated to a method definition specialised (and bound) on WIDGET-CLASS
with a INITIALIZER declaration. The BODY is wrapped in a WITH-SLOTS-BOUND form.

See CL+QT:DEFMETHOD
See QTOOLS:WITH-SLOTS-BOUND</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-MENU"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-MENU">DEFINE-MENU</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a menu on WIDGET-CLASS with NAME and CONTENTS.

By default the following content types are available:
  A :MENU form is followed by a menu text string and a
  body of content forms.

  A :SEPARATOR simply adds a separator at its point to
  the parent and takes no further arguments.

  An :ITEM form is followed by an identifier, which may
  be a symbol, string, or list. In the case of a symbol,
  the item is taken from the according slot on the widget.
  In the case of a string the string serves as the text
  for the item. For a list, the first serves as the text
  and the second as an input acceptable to MAKE-CHORD.
  The body of the item form can be arbitrary lisp forms
  to be executed when the item is triggered.

See QTOOLS:MAKE-CHORD.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-MENU-CONTENT-TYPE"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-MENU-CONTENT-TYPE">DEFINE-MENU-CONTENT-TYPE</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a new menu content type processor NAME.

See (SETF QTOOLS:MENU-CONTENT-TYPE).</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-METHOD-DECLARATION"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-METHOD-DECLARATION">DEFINE-METHOD-DECLARATION</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Define a new method declaration function of NAME.

See (SETF QTOOLS:METHOD-DECLARATION).</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-OVERRIDE"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-OVERRIDE">DEFINE-OVERRIDE</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Define a new OVERRIDE on WIDGET-CLASS with ARGS.

This is translated to a method definition with METHOD-NAME that specialises
 (and binds) on WIDGET-CLASS, with ARGS appended to the list, and an OVERRIDE
declaration in the body. Additionally, the body is wrapped in a WITH-SLOTS-BOUND
to allow for convenient slot access.

See CL+QT:DEFMETHOD
See QTOOLS:WITH-SLOTS-BOUND
See CommonQt/override</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-SIGNAL"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-SIGNAL">DEFINE-SIGNAL</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Define a new SIGNAL on WIDGET-CLASS with ARGS.

This evaluates to a simple SET-WIDGET-CLASS-OPTION that adds a new :SIGNAL
definition to the WIDGET-CLASS. The signal signature is generated using
SPECIFIED-TYPE-METHOD-NAME.

See CommonQt/signals</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-SIGNAL-METHOD"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-SIGNAL-METHOD">DEFINE-SIGNAL-METHOD</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Shorthand to define wrapper methods for the given signal.

NAME ::= signal | (signal method-name)
ARGS ::= ARG*
ARG  ::= qt-type | (qt-type*)

A methods with name NAME are generated that takes arguments the
object to signal and the specified arguments with their according types.
You may either specify a single type on each argument, or lists of
correlating types for each argument. Each type is resolved as per
ECL-TYPE-FOR to a type to use in the method specializers. The signal
method to call is computed as per SPECIFIED-TYPE-METHOD-NAME.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-SLOT"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-SLOT">DEFINE-SLOT</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Define a new SLOT on WIDGET-CLASS with ARGS.

ARGS is a list of arguments, where each item is a list of two values,
the first being the symbol used to bind the value within the function
body, and the second being a type specifier usable for the slot definition
and, if possible, as a specializer in the method.

In effect this translates to a method definition with METHOD-NAME that
specialises (and binds) on WIDGET-CLASS, with additional required arguments
ARGS, and a SLOT declaration. Additionally, the body is wrapped in a
WITH-SLOTS-BOUND to allow for convenient slot access.

See CL+QT:DEFMETHOD
See QTOOLS:WITH-SLOTS-BOUND
See CommonQt/slots</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-SUBWIDGET"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-SUBWIDGET">DEFINE-SUBWIDGET</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Defines a new sub-widget of NAME on WIDGET-CLASS.

What this means is that a finalized slot of NAME is added to WIDGET-CLASS
as well as an initializer function for the slot. The slot for the sub-widget 
is set to the value returned by the INITFORM, after which BODY is run. BODY
is wrapped in a WITH-SLOTS-BOUND form, so all slots are conveniently available.

See QTOOLS:DEFINE-INITIALIZER</pre>
                </article>
              </li><li>
                <a name="QTOOLS:DEFINE-WIDGET"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:DEFINE-WIDGET">DEFINE-WIDGET</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Shorthand over DEFCLASS.

Adds WIDGET as direct-superclass if it does not appear as a
superclass to the specified direct-superclasses. Sets 
WIDGET-CLASS as metaclass and qt-class as the qt-superclass 
after resolving it through FIND-QT-CLASS-NAME.

All options are fused as per FUSE-ALISTS. You may therefore use
the same form multiple times.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:Q+"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:Q+">Q+</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Emits a function call to the Q+ FUNCTION with ARGS.

This macro does a bit of a complicated thing:
Firstly, it calls ENSURE-Q+-METHOD on FUNCTION to
make sure that the function object exists at compile
time. Then it emits a PROGN form that contains two
forms, the first of which is a LOAD-TIME-VALUE form
with a call to ENSURE-Q+-METHOD again. This is required
since the function compiled by ENSURE-Q+-METHOD is not
dumped to file anywhere and thus must be recreated at
load time to be available. The second form in the PROGN
is the actual function call, using the proper symbol
from the *TARGET-PACKAGE*.

See QTOOLS:ENSURE-Q+-METHOD</pre>
                </article>
              </li><li>
                <a name="QTOOLS:Q+FUN"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:Q+FUN">Q+FUN</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Emits a form that evaluates to the function object of FUNCTION.

Specifically, it returns a LOAD-TIME-VALUE form that evaluates to
the function object, while ensuring that the function does indeed
exist.

See QTOOLS:ENSURE-Q+-METHOD</pre>
                </article>
              </li><li>
                <a name="QTOOLS:QTENUMCASE"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:QTENUMCASE">QTENUMCASE</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Just like CASE, but for Qt enums using QT:ENUM=.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:SIGNAL!"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:SIGNAL!">SIGNAL!</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Macro for a more lisp-y writing of EMIT-SIGNAL.
Function should be a list of the METHOD-NAME followed by Qt argument types.
The effective method name is computed as per SPECIFIED-TYPE-METHOD-NAME.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WITH-FINALIZING"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:WITH-FINALIZING">WITH-FINALIZING</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Executes the body as by LET and calls FINALIZE on all the objects introduced by
the bindings on completion of the body. If an error occurs during the binding phase,
all objects bound up until that point are still finalized.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WITH-FINALIZING*"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:WITH-FINALIZING*">WITH-FINALIZING*</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Executes the body as by LET* and calls FINALIZE on all the objects introduced by
the bindings on completion of the body. If an error occurs during the binding phase,
all objects bound up until that point are still finalized.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WITH-GC-FINALIZED"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:WITH-GC-FINALIZED">WITH-GC-FINALIZED</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Creates bindings as per LET with the special note that each value of a binding is wrapped
in a GC-FINALIZED. Each bound symbol is shadowed by a SYMBOL-MACROLET, which evaluates to
the bound value as per UNBOX.

In other words, this will look like a standard LET to you, but each value of the let is
automatically ensured to be GC-ed and FINALIZEd once the body exits.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:WITH-SLOTS-BOUND"/>
                <article>
                  <header>
                    <span>MACRO</span>
                    <code>
                      <h4><a href="#QTOOLS:WITH-SLOTS-BOUND">WITH-SLOTS-BOUND</a></h4>
                      <span/>
                      <span>(&amp;REST ARGS)</span>
                    </code>
                  </header>
                  <pre>Turns into a WITH-SLOTS with all direct-slots of CLASS.
Class is resolved as per ENSURE-CLASS.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*GENERATED-MODULES*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*GENERATED-MODULES*">*GENERATED-MODULES*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>A list of loaded smoke modules when PROCESS-ALL-METHODS is called.
This is useful to keep track over environments which modules are
actually available for compilation.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*METHOD*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*METHOD*">*METHOD*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Contains the whole DEFMETHOD form that is currently being processed.
If you modify the contents of this variable, the changes will be reflected
in the outputted method definition form. However, no declaration that is
processed by method-declarations will ever appear in the output.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*OPERATOR-MAP*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*OPERATOR-MAP*">*OPERATOR-MAP*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>A hash-table of C++ operators to CL function names.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*QMETHODS*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*QMETHODS*">*QMETHODS*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Table mapping a *TARGET-PACKAGE* symbol to a list of
associated Qt methods. This table should only be changed
by PROCESS-METHOD. If you modify yourself without knowing
exactly what you're doing you'll most likely run into problems.

Methods/functions contained in this table are available
for compilation.

See QTOOLS:PROCESS-METHOD
See QTOOLS:COMPILE-WRAPPER</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*QT-CLASS-MAP*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*QT-CLASS-MAP*">*QT-CLASS-MAP*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>An EQUALP hash-table of all Qt4.8 class names to themselves as strings.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*QT-CLASS-VECTOR*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*QT-CLASS-VECTOR*">*QT-CLASS-VECTOR*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>A vector of all Qt4.8 class names as strings.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*SMOKE-MODULES*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*SMOKE-MODULES*">*SMOKE-MODULES*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>A list of all possible smoke modules.

These modules provide the C wrappers required to work with
the respective Qt parts. Usually you will only need
QTCORE and QTGUI, but for example if you need OpenGL support
you'll want QTOPENGL, or if you need phonon, you'll want
the PHONON module.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*TARGET-PACKAGE*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*TARGET-PACKAGE*">*TARGET-PACKAGE*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>The package used to store Qt wrapper functions that the Q+ system uses.
By default this package is called &quot;Q+&quot;. The package should not contain
any systems except for those generated by Qtools.</pre>
                </article>
              </li><li>
                <a name="QTOOLS:*WIDGET*"/>
                <article>
                  <header>
                    <span>SPECIAL</span>
                    <code>
                      <h4><a href="#QTOOLS:*WIDGET*">*WIDGET*</a></h4>
                      <span/>
                      <span/>
                    </code>
                  </header>
                  <pre>Bound to the class-name of the widget during component expansion and
bound to the class instance during initialization.</pre>
                </article>
              </li></ul>
          </li></ul>
      </article>
    </div>
  </body>
</html>
